{"version":3,"file":"day8.re_frame.http_fx.js","sources":["day8/re_frame/http_fx.cljs"],"mappings":";;;;;AAsBA;;;2CAAA,+EAAAA,1HAAMG,8FAEHC,WAAWC,WAAWC;AAFzB,AAAA,IAAAL,aAAAD;qBAAA,AAAAE,4CAAAD,WAAA,IAAA,5EAEgCM;eAFhC,AAAAL,4CAAAD,WAAA,IAAA,tEAEyCO;AAFzC,AAIE,oBAAID;AACF,QAACH,2CAAAA,qDAAAA,ZAAWI,iCAAAA;;AACZ,IAAMC,UAAQ,uGAAA,2CAAA,sEAAA,qFAAA,sFAAA,mGAAA,teAACC,qMACmB,AAAaJ,sFACb,AAAeA,mFACf,AAAeA,+FACf,AAAmBA,4HACfA,5BAAwB,iBAAAK,WAAA;AAAA,AAAA,0CAAAA,nCAACC;aAC/CJ;AANhB,AAOE,QAACH,2CAAAA,oDAAAA,XAAWI,gCAAAA;;;AAGlB,kDAAA,0DAAAI,5GAAMM;AAAN,AAAA,IAAAL,aAAAD;IAAAC,iBAAA,EAAA,EAAA,EAAA,CAAAA,cAAA,QAAA,EAAA,EAAA,CAAA,AAAAA,iDAAA,WAAA,CAAAC,gCAAA,AAAAD,+BAAA,KAAA,OAAA,QAAA,AAAAE,8CAAAC,mBAAAH,YAAAA;cAAAA,VACUM;iBADV,AAAAF,4CAAAJ,eAAA,iEAAA,mFAAA,5NAEWV;iBAFX,AAAAc,4CAAAJ,eAAA,gEAAA,mFAAA,3NAEsBT;AAFtB,AAME,IAAMgB,MAAI,KAAKC;AAAf,kHACMF,rDACA,6DAAA,yGAAA,tKAACG,gHACUF,iHACA,yFAAA,zFAACK,gDAAQvB,9UAIpB,OAAC4B;kBAJUP;AAAA,AACU,IAAAG,WAAU,wDAAAH,xDAACK,6CAAKzB;AAAhB,AAAA,oHAAAuB,6CAAAA,zJAACC,uDAAAA,iEAAAA;;CADX;kBAAAH;AAAA,AAEU,IAAAK,WAAU,wDAAAL,xDAACI,6CAAKxB;AAAhB,AAAA,oHAAAyB,6CAAAA,zJAACF,uDAAAA,iEAAAA;;CACFP,WACpB,mHAAA;;AA0BR,oCAAA,pCAAMW,gFACHZ;AADH,AAIE,IAEMa,mBAAiB,gDAAA,9CAAI,AAACC,4BAAYd,UAASA,2FAASA;AAF1D,AAGE,IAAAe,aAAA,AAAAC,cAAgBH;IAAhBI,eAAA;IAAAC,eAAA;IAAAC,WAAA;;AAAA,AAAA,GAAA,AAAA,CAAAA,WAAAD;AAAA,kBAAA,AAAAD,kDAAAE,hEAAQnB;AAAR,AAAA,AACE,IAAA4B,iBAAA,gDAAI5B,hDAAQD;AAAZ,AAAA,6GAAA6B,mDAAAA,/JAAmCE,uDAAAA,uEAAAA;;AADrC;AAAA,eAAAf;eAAAE;eAAAC;eAAA,CAAAC,WAAA;;;;;;;AAAA,IAAAC,qBAAA,AAAAJ,cAAAD;AAAA,AAAA,GAAAK;AAAA,AAAA,IAAAL,iBAAAK;AAAA,AAAA,GAAA,AAAAC,6BAAAN;AAAA,IAAAO,kBAAA,AAAAC,sBAAAR;AAAA,AAAA,eAAA,AAAAS,qBAAAT;eAAAO;eAAA,AAAAG,gBAAAH;eAAA;;;;;;;AAAA,kBAAA,AAAAI,gBAAAX,9BAAQf;AAAR,AAAA,AACE,IAAA6B,iBAAA,gDAAI7B,hDAAQD;AAAZ,AAAA,6GAAA8B,mDAAAA,/JAAmCC,uDAAAA,uEAAAA;;AADrC;AAAA,eAAA,AAAAH,eAAAZ;eAAA;eAAA;eAAA;;;;;;;;AAAA;;;;;;AAGJ,IAAAgB,iBAAA;IAAAC,iBAAoBpB;AAApB,AAAA,yGAAAmB,eAAAC,iDAAAD,eAAAC,vLAACC,qDAAAA,oFAAAA","names":["p__27785","vec__27789","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","day8.re-frame.http-fx/ajax-xhrio-handler","on-success","on-failure","xhrio","success?","response","details","cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic","G__27798","goog.net.ErrorCode/getDebugMessage","p__27812","map__27813","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$3","day8.re-frame.http-fx/request->xhrio-options","request","api","js/goog.net.XhrIo","cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic","p1__27809#","p1__27810#","cljs.core.partial.cljs$core$IFn$_invoke$arity$4","G__27819","re-frame.core/dispatch","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","G__27820","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic","day8.re-frame.http-fx/http-effect","seq-request-maps","cljs.core/sequential?","seq__27830","cljs.core/seq","chunk__27831","count__27832","i__27833","temp__5457__auto__","cljs.core/chunked-seq?","c__4319__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/count","cljs.core/first","cljs.core/next","G__27834","G__27835","ajax.core/ajax-request","G__27850","G__27851","re-frame.core/reg-fx"],"sourcesContent":["(ns day8.re-frame.http-fx\n  (:require\n    [goog.net.ErrorCode :as errors]\n    [re-frame.core :refer [reg-fx dispatch console]]\n    [ajax.core :as ajax]\n    #_[cljs.spec :as s]))\n\n;; I provide the :http-xhrio effect handler leveraging cljs-ajax lib\n;; see API docs https://github.com/JulianBirch/cljs-ajax\n;; Note we use the ajax-request.\n;;\n;; Deviation from cljs-ajax options in request\n;; :handler       - not supported, see :on-success and :on-failure\n;; :on-success    - event vector dispatched with result\n;; :on-failure    - event vector dispatched with result\n;;\n;; NOTE: if you need tokens or other values for your handlers,\n;;       provide them in the on-success and on-failure event e.g.\n;;       [:success-event \"my-token\"] your handler will get event-v\n;;       [:success-event \"my-token\" result]\n\n\n(defn ajax-xhrio-handler\n  \"ajax-request only provides a single handler for success and errors\"\n  [on-success on-failure xhrio [success? response]]\n  ; see http://docs.closure-library.googlecode.com/git/class_goog_net_XhrIo.html\n  (if success?\n    (on-success response)\n    (let [details (merge\n                    {:uri             (.getLastUri xhrio)\n                     :last-method     (.-lastMethod_ xhrio)\n                     :last-error      (.getLastError xhrio)\n                     :last-error-code (.getLastErrorCode xhrio)\n                     :debug-message   (-> xhrio .getLastErrorCode (errors/getDebugMessage))}\n                    response)]\n      (on-failure details))))\n\n\n(defn request->xhrio-options\n  [{:as   request\n    :keys [on-success on-failure]\n    :or   {on-success      [:http-no-on-success]\n           on-failure      [:http-no-on-failure]}}]\n  ; wrap events in cljs-ajax callback\n  (let [api (new js/goog.net.XhrIo)]\n    (-> request\n        (assoc\n          :api     api\n          :handler (partial ajax-xhrio-handler\n                            #(dispatch (conj on-success %))\n                            #(dispatch (conj on-failure %))\n                            api))\n        (dissoc :on-success :on-failure))))\n\n;; Specs commented out until ClojureScript has a stable release of spec.\n;\n;(s/def ::method keyword?)\n;(s/def ::uri string?)\n;(s/def ::response-format (s/keys :req-un [::description ::read ::content-type]))\n;(s/def ::format (s/keys :req-un [::write ::content-type]))\n;(s/def ::timeout nat-int?)\n;(s/def ::params any?)\n;(s/def ::headers map?)\n;(s/def ::with-credentials boolean?)\n;\n;(s/def ::on-success vector?)\n;(s/def ::on-failure vector?)\n;\n;(s/def ::request-map (s/and (s/keys :req-un [::method ::uri ::response-format ::on-success ::on-failure]\n;                                    :opt-un [::format ::timeout ::params ::headers ::with-credentials])\n;                            (fn [m] (if (contains? m :params)\n;                                      (contains? m :format)\n;                                      true))))\n;\n;(s/def ::sequential-or-map (s/or :request-map ::request-map :seq-request-maps (s/coll-of ::request-map\n;                                                                                         :kind sequential?\n;                                                                                         :into [])))\n\n(defn http-effect\n  [request]\n  #_(when-not (s/valid? ::sequential-or-map request)\n      (throw (ex-info \"http-xhrio fx: spec error\" (s/explain-data ::sequential-or-map request))))\n  (let [#_ #_ [conform-val v] (s/conform ::sequential-or-map request)\n        #_ #_ seq-request-maps (if (= :seq-request-maps conform-val) v [v])\n        seq-request-maps (if (sequential? request) request [request])]\n    (doseq [request seq-request-maps]\n      (-> request request->xhrio-options ajax/ajax-request))))\n\n(reg-fx :http-xhrio http-effect)\n"]}